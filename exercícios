//EXERCÍCIO 01
package main

import "fmt"

// Crie uma função que receba um slice de inteiros e retorne a média aritmética dos valores.

func media(num []int, tamanho int) int {
	var i, r, x int

	for i = 0; i < len(num); i++ {
		x += num[i]
	}
	r = x / tamanho
	return r
}

func main() {
	num := []int{10, 10, 10, 10, 10}
	resultado := media(num, len(num))
	fmt.Println("A média aritimética será:", resultado)
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//EXERCÍCIO 02
package main

import (
	"bufio"
	"fmt"
	"os"
)

// Crie uma função que receba uma string e retorne a quantidade de vogais presentes.
func v(frase string) int {
	var k int
	for i := 0; i < len(frase); i++ {
		if frase[i] == 'a' || frase[i] == 'e' || frase[i] == 'i' || frase[i] == 'o' || frase[i] == 'u' {

			k++
		}
	}
	return k
}

func main() {
	newScanner := bufio.NewScanner(os.Stdin)
	fmt.Println("Digite uma frase")
	newScanner.Scan()
	frase := newScanner.Text()
	resultado := v(frase)
	fmt.Printf("A frase %s tem %d vogais", frase, resultado)

}

//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 03
package main

import "fmt"

//Crie uma função que receba um slice de strings e retorne a concatenação de todas as strings.

func conc(frase []string, frase2 string) string {
	for i := 0; i < len(frase); i++ {
		frase2 += frase[i]
	}
	return frase2
}

func main() {
	var frase2, resultado, x string
	var frase []string
	for i := 0; i < 10; i++ {
		fmt.Println("Digite uma palavra")
		fmt.Scan(&x)
		frase = append(frase, x)

	}
	resultado = conc(frase, frase2)
	fmt.Println("A concatenação das suas palvras ficará", resultado)
}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 04
package main

import "fmt"

//Crie uma função que receba um slice de inteiros e retorne o segundo maior valor.

func maiorvalor(num []int) int {
	var x, y int
	for i := 0; i < len(num)-1; i++ {
		if num[i+1] > num[i] {
			x = num[i+1]
		}
	}
	for i := 0; i < len(num); i++ {
		if num[i] < x && num[i+1] > num[i] {
			y = num[i]
		}
	}
	return y
}

func main() {
	var x = []int{1, 2, 3, 4, 5, 6, 7, 8}
	result := maiorvalor(x)
	fmt.Println(result)
}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 05
package main

import "fmt"

//Crie uma função que receba um slice de inteiros e um valor inteiro
//retorne a posição do primeiro elemento igual ao valor no slice.
//Caso não encontre, retorne -1.

func sliceint(num []int, x int) (int, error) {
	var y int
	if x < 0 && x > len(num) {
		return 0, fmt.Errorf("-1")
	}
	num = append(num[x-1:], num[:x]...)
	for i := 0; i < 1; i++ {
		y = num[i]
	}

	return y, nil
}

func main() {
	var num = []int{1, 2, 9, 4, 5, 6, 7}
	x := 3
	result, err := sliceint(num, x)
	if err != nil {
		fmt.Println(err)
		return
	} else {
		fmt.Println(result)
	}

}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 06
package main

import (
	"fmt"
)

//Escreva uma função que receba um slice de strings como parâmetro
//retorne uma string com todas as strings concatenadas e separadas por vírgulas.
//Caso o slice esteja vazio, retorne um erro.

func conca(s []string) (string, error) {
	var frase string
	for i := 0; i < len(s); i++ {
		frase += s[i] + ","

	}
	if s == nil {
		fmt.Errorf("erro")
	}
	return frase, nil
}

func main() {
	var s = []string{"a", "b", "c", "d"}
	frase, err := conca(s)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(frase)
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 07
package main

import "fmt"

//Crie uma função que receba um slice de inteiros e uma função como parâmetros.
//A função deve aplicar a função recebida em cada elemento do slice e retornar um novo slice com os resultados.
//Caso o slice esteja vazio, retorne um erro.

type media2 func(x int, y int) int

func abcc(num []int, m media2) (int, error) {
	var x, y int
	x = len(num)
	for i := 0; i < len(num); i++ {
		y += num[i]
	}

	if num == nil {
		return 0, fmt.Errorf("erro")
	}
	return m(x, y), nil
}
func main() {
	var num = []int{1, 2, 3, 4, 5}
	resultado := func(x int, y int) int {
		return x / y

	}
	resultado2, _ := abcc(num, resultado)
	fmt.Println(resultado2)

}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 08
//errado
package main

import "fmt"

//Escreva uma função que receba um slice de inteiros como parâmetro
//retorne um novo slice com apenas os números pares contidos no slice.
//Caso o slice esteja vazio, retorne um erro.

func slice2(num []int) ([]int, error) {
	var num2 []int
	for i := 0; i < len(num); i++ {
		if num[i]%2 == 0 {
			num2 = append(num2, num[i])
		}

	}
	if num == nil {
		return nil, fmt.Errorf("erro")
	}
	return num2, nil
}

func main() {
	var num = []int{1, 2, 3, 4, 5}
	resultado, err := slice2(num)
	if err != nil {
		fmt.Println("Número invalido")
	} else {
		fmt.Println(resultado)
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 09
package main

import (
	"fmt"
	"strings"
)

//Crie uma função que receba uma string como parâmetro e retorne um novo slice com todas as palavras contidas na string.
//Considere que as palavras são separadas por espaços em branco.
//Caso a string seja vazia, retorne um erro.

func string2(frase string) ([]string, error) {
	var frase2 []string
	
	frase2 = strings.Split(frase, " ")
	if len(frase) == 0 {
		return nil, fmt.Errorf("erro")
	}

	return frase2, nil
}

func main() {
	frase := "Eu quero tirar 10 na prova"
	resultado, err := string2(frase)
	if err != nil {
		fmt.Println("String vazia")
	} else {
		fmt.Println(resultado)
	}

}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 10
package main

import "fmt"

//Escreva uma função que receba um slice de inteiros como parâmetro
//retorne um novo slice com os valores ordenados de forma crescente.
//Caso o slice esteja vazio, retorne um erro

func slice3(num []int) ([]int, error) {
	var num2 []int
	var x int
	for i := 0; i < len(num)-1; i++ {
		if num[i+1] > num[i] {
			num2[i] = num[i]

		} else if num[i+1] < num[i] {
			x = num[i+1]
			continue
		} else if x < num[i] {
			num2[i] = x
		}
	}
	if len(num) == 0 {
		return nil, fmt.Errorf("error")
	}
	return num2, nil
}

func main() {
	var num = []int{2, 1, 3, 4, 5, 6, 7}
	result, err := slice3(num)
	if err != nil {
		fmt.Println("número invalido")
	} else {
		fmt.Println(result)
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////
EXERCÍCIO 11
